<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《枪炮、病菌与钢铁：人类社会的命运》</title>
    <link href="/2022/03/03/%E3%80%8A%E6%9E%AA%E7%82%AE%E3%80%81%E7%97%85%E8%8F%8C%E4%B8%8E%E9%92%A2%E9%93%81%EF%BC%9A%E4%BA%BA%E7%B1%BB%E7%A4%BE%E4%BC%9A%E7%9A%84%E5%91%BD%E8%BF%90%E3%80%8B/"/>
    <url>/2022/03/03/%E3%80%8A%E6%9E%AA%E7%82%AE%E3%80%81%E7%97%85%E8%8F%8C%E4%B8%8E%E9%92%A2%E9%93%81%EF%BC%9A%E4%BA%BA%E7%B1%BB%E7%A4%BE%E4%BC%9A%E7%9A%84%E5%91%BD%E8%BF%90%E3%80%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>阅读</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>桶排序</title>
    <link href="/2022/03/03/%E6%A1%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/03/03/%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_27124771/article/details/87651495">图解桶排序</a></p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>非比较排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计数排序</title>
    <link href="/2022/03/03/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/03/03/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>计数排序是一种稳定的线性时间排序算法，计数排序不是比较排序，排序的速度快于任何比较排序算法，计数排序可以配合基数排序，能够更有效排序数据范围很大的数组</p><h2 id="一、计数排序步骤"><a href="#一、计数排序步骤" class="headerlink" title="一、计数排序步骤"></a>一、计数排序步骤</h2><ul><li>1.找出待排序的数组中最大和最小的元素</li><li>2.统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li><li>3.对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li><li>4.反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li></ul><h2 id="二、计数排序实现"><a href="#二、计数排序实现" class="headerlink" title="二、计数排序实现"></a>二、计数排序实现</h2><figure class="highlight stan"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs stan"><span class="hljs-meta">#include &quot;<span class="hljs-string">utili.h</span>&quot;</span><br><br><span class="hljs-comment">//假设要排序的数字都是小于100的</span><br><span class="hljs-type">void</span> count_sort( <span class="hljs-type">int</span> <span class="hljs-title">data</span>[], <span class="hljs-type">int</span> <span class="hljs-built_in">size</span> )<br>&#123;<br>    <span class="hljs-type">int</span> count_arr[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> temp[<span class="hljs-built_in">size</span>];<br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-keyword">for</span> ( k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">100</span>; k++ )<br>        count_arr[k] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>; i++ )<br>        count_arr[<span class="hljs-title">data</span>[i]]++;<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++ )<br>        count_arr[i] = count_arr[i-<span class="hljs-number">1</span>] + count_arr[i];<br>    <span class="hljs-keyword">for</span> ( j = <span class="hljs-built_in">size</span>; j &gt; <span class="hljs-number">0</span>; j-- )<br>    &#123;<br>        temp[--count_arr[<span class="hljs-title">data</span>[j-<span class="hljs-number">1</span>]]] = <span class="hljs-title">data</span>[j-<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>; ++i )<br>        <span class="hljs-title">data</span>[i] = temp[i];<br>&#125;<br></code></pre></td></tr></table></figure><div align="center"><img src="counting_sort1.gif"><></div><h2 id="三、性能分析"><a href="#三、性能分析" class="headerlink" title="三、性能分析"></a>三、性能分析</h2><ul><li>时间复杂度：O(N+k)</li><li>空间复杂度：O(N+k)</li><li>稳定性：稳定</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>非比较排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基数排序</title>
    <link href="/2022/03/03/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/03/03/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>基数排序是将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，一次进行一次排序。这样从最低位排序一直到最高位排序完成之后，数列就变成一个有序序列</p><p><strong>NOTE:</strong> 基数排序只能排序非负整数</p><h2 id="一、效率"><a href="#一、效率" class="headerlink" title="一、效率"></a>一、效率</h2><p>基数排序的时间复杂度为 O(k*n)其中n是排序元素个数，k是数字位数。需要注意的是这个时间复杂度不一定优于 O(n*log_n)</p><h2 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h2><p>基数排序的过程图示如下：</p><div align="center"><img src="radix_sort1.jpg"></img></div><figure class="highlight stan"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><pre><code class="hljs stan"><span class="hljs-type">int</span> maxbit( <span class="hljs-type">int</span> <span class="hljs-title">data</span>[], <span class="hljs-type">int</span> <span class="hljs-built_in">size</span> )      <span class="hljs-comment">//辅助函数，求数据的最大位数</span><br>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-comment">//先求出最大数，再求最大数的位数.</span><br>    <span class="hljs-type">int</span> maxData = <span class="hljs-title">data</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">size</span>; ++i )<br>    &#123;<br>        <span class="hljs-keyword">if</span> ( <span class="hljs-title">data</span>[i] &gt; maxData )<br>            maxData = <span class="hljs-title">data</span>[i];<br>    &#125;<br>    i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> ( maxData &gt;= <span class="hljs-number">10</span> )<br>    &#123;<br>        maxData /= <span class="hljs-number">10</span>;<br>        ++i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><span class="hljs-type">void</span> radix_sort( <span class="hljs-type">int</span> <span class="hljs-title">data</span>[], <span class="hljs-type">int</span> <span class="hljs-built_in">size</span> )<br>&#123;<br>    <span class="hljs-type">int</span> d = maxbit( <span class="hljs-title">data</span>, <span class="hljs-built_in">size</span> );<br>    <span class="hljs-comment">//int *temp = (int *)malloc( sizeof(int)*size );</span><br>    <span class="hljs-type">int</span> temp[<span class="hljs-built_in">size</span>];<br>    <span class="hljs-type">int</span> count[<span class="hljs-number">10</span>];                  <span class="hljs-comment">//计数器</span><br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-type">int</span> radix = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">1</span>; i &lt;= d; i++ )<br>    &#123;<br>        <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++ )<br>            count[j] = <span class="hljs-number">0</span>;               <span class="hljs-comment">//每次分配前清空计数器</span><br><br>        <span class="hljs-comment">//(1)</span><br>        <span class="hljs-comment">//将data中第i位为j的个数保存在count[j]中</span><br>        <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">size</span>; j++ )<br>        &#123;<br>            k = ( <span class="hljs-title">data</span>[j] / radix ) % <span class="hljs-number">10</span>;   <span class="hljs-comment">//k为data中每个数第i位的数字</span><br>            count[k]++;<br>        &#125;<br>        <span class="hljs-comment">//count[j]中保存第i位小于j的数字的个数</span><br>        <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++ )<br>        &#123;<br>            count[j] = count[j-<span class="hljs-number">1</span>] + count[j];<br>        &#125;<br>        <span class="hljs-keyword">for</span> ( j = <span class="hljs-built_in">size</span>-<span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j-- )<br>        &#123;<br>            k = ( <span class="hljs-title">data</span>[j] / radix ) % <span class="hljs-number">10</span>;<br>            <span class="hljs-comment">//printf( &quot;k = %d, data[%d] = %d\n&quot;, k, j, data[j] );</span><br>            temp[count[k]-<span class="hljs-number">1</span>] = <span class="hljs-title">data</span>[j];<br>            count[k]--;<br>        &#125;<br>        <span class="hljs-comment">//(2)</span><br>        <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">size</span>; j++ )<br>        &#123;<br>            <span class="hljs-comment">//printf( &quot;%d &quot;, temp[j] );</span><br>            <span class="hljs-title">data</span>[j] = temp[j];<br>        &#125;<br>        radix = radix * <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;  <br></code></pre></td></tr></table></figure><div align="center"><img src="radix_sort.gif"></div>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>非比较排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>希尔排序</title>
    <link href="/2022/03/03/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/03/03/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<div align="center"><img src="希尔排序.png"></img></div><div align="center"><img src="希尔排序2.png"></img></div><figure class="highlight arduino"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shell</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> h = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">while</span> (h &lt; (size / <span class="hljs-number">3</span>))<br>    &#123;<br>        h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (h &gt;= <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h; i &lt; size; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt;= h &amp;&amp; nums[j] &lt; nums[j - h]; j -= h)<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(nums, j, j - h);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; nums.<span class="hljs-built_in">size</span>(); k++)<br>                cout &lt;&lt; nums[k] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>            cout &lt;&lt; endl;<br>        &#125;<br>        h /= <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;  <br></code></pre></td></tr></table></figure><p>京东面试题2017年：</p><p>对关键字{10,20,8,25,35,6,18,30,5,15,28}序列进行希尔排序，取增量d &#x3D;5时，排序结果为（）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">A</span>. &#123;<span class="hljs-number">6</span>,<span class="hljs-number">18</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">15</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">25</span>,<span class="hljs-number">35</span>,<span class="hljs-number">28</span>&#125;<br><span class="hljs-attribute">B</span>. &#123;<span class="hljs-number">10</span>,<span class="hljs-number">18</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">15</span>,<span class="hljs-number">6</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">25</span>,<span class="hljs-number">35</span>,<span class="hljs-number">28</span>&#125;<br><span class="hljs-attribute">C</span>. &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">15</span>,<span class="hljs-number">6</span>,<span class="hljs-number">18</span>,<span class="hljs-number">30</span>,<span class="hljs-number">25</span>,<span class="hljs-number">35</span>,<span class="hljs-number">28</span>&#125;<br><span class="hljs-attribute">D</span>. &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">15</span>,<span class="hljs-number">18</span>,<span class="hljs-number">25</span>,<span class="hljs-number">28</span>,<span class="hljs-number">35</span>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>比较排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2022/03/03/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/03/03/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、经典归并排序"><a href="#一、经典归并排序" class="headerlink" title="一、经典归并排序"></a>一、经典归并排序</h2><p>归并排序就是将要排序的数组分成两部分，每一部分都排好序，再将这两部分归并为一个数组，每一部分的排序又采用归并排序。</p><p>归并排序按照空间的使用上来分主要分为两种：普通归并和原地归并。按照归并的方向可以分为自顶向下归并和自底向上归并。</p><h3 id="1-merge函数"><a href="#1-merge函数" class="headerlink" title="1. merge函数"></a>1. merge函数</h3><p>归并排序最主要的一个函数就是merge，函数接口如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> data[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> end)</span></span>;<br></code></pre></td></tr></table></figure><p>这个函数负责将data数组中start-mid子数组和mid-end子数组进行原地归并，这个函数的前提条件是两个子数组都已经排好序。下面是这个函数的具体实现代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//归并两个排好序的数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> h)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = l, j = m + <span class="hljs-number">1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">aux</span><span class="hljs-params">(nums.begin(), nums.end())</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = l; k &lt;= h; k++)<br>    &#123;<br>        <span class="hljs-comment">//i&gt;=mid说明前半部分先被合并完，直接将后半部分剩余的元素接到data后面</span><br>        <span class="hljs-keyword">if</span> (i &gt; m)<br>            nums[k] = aux[j++];<br>        <span class="hljs-comment">//i&gt;=mid说明后半部分先被合并完，直接将前半部分剩余的元素接到data后面</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; h)<br>            nums[k] = aux[i++];<br>        <span class="hljs-comment">//两者中选择较小的放到data中</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aux[i] &lt; aux[j])<br>            nums[k] = aux[i++];<br>        <span class="hljs-keyword">else</span><br>            nums[k] = aux[j++];<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>归并排序最主要的函数就是merge函数，所以保证将merge函数写正确是非常重要的，写归并排序的时候可以先写一个merge函数，然后模拟几个环境测试一下，测试没有问题之后再进行下一步，否则如果一次性将整个归并算法全部写出，出现问题之后，因为递归层数比较多，找起来很麻烦。写好了merge函数，不管是自顶向下还是自底向上归并都只是对merge函数不同方式的调用而已。</p><div align="center"><img src="merge_sort.gif" /></div><h4 id="2-2-自底向上归并"><a href="#2-2-自底向上归并" class="headerlink" title="2.2 自底向上归并"></a>2.2 自底向上归并</h4><p>自底向上：与自顶向下刚好相反，先从子数组依赖树的最低端出发，保证在为一个数组排序时，它的两个部分都已经被排好序，（自顶而下是假设已经排好序，两个不一样）</p><h5 id="自底向上代码实现"><a href="#自底向上代码实现" class="headerlink" title="自底向上代码实现"></a>自底向上代码实现</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort2</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> sz = <span class="hljs-number">1</span>; sz &lt; size; sz += sz)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> lo = <span class="hljs-number">0</span>; lo &lt; size - sz; lo += sz + sz)<br>        &#123;<br>            <span class="hljs-type">int</span> end = lo + sz + sz - <span class="hljs-number">1</span> &lt; size - <span class="hljs-number">1</span> ? lo + sz + sz - <span class="hljs-number">1</span> : size - <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">merge</span>(nums, lo, lo + sz - <span class="hljs-number">1</span>, end);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div align="center"><img src="merge_sort3.png"></img></div><h3 id="2-归并排序的两种方向："><a href="#2-归并排序的两种方向：" class="headerlink" title="2. 归并排序的两种方向："></a>2. 归并排序的两种方向：</h3><p>为了直观的理解自顶而下和自底向上，我放了一张图。</p><div align="center"><img src="merge_sort1.png"></img></div><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><ul><li>时间复杂度：NlogN </li><li>空间复杂度：N</li><li>稳定性：稳定</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>比较排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆排序</title>
    <link href="/2022/03/03/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/03/03/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、堆结构"><a href="#一、堆结构" class="headerlink" title="一、堆结构"></a>一、堆结构</h2><h3 id="1-堆的定义"><a href="#1-堆的定义" class="headerlink" title="1. 堆的定义"></a>1. 堆的定义</h3><p>堆中某个节点的值总是大于等于其子节点的值，并且堆是一颗完全二叉树。</p><p>堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k&#x2F;2，<br>而它的两个子节点的位置分别为 2k 和 2k+1。</p><p>这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系。</p><figure class="highlight csharp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> heap[maxN+<span class="hljs-number">1</span>];<br><span class="hljs-built_in">int</span> N = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">bool</span> isEmpty &#123;<span class="hljs-keyword">return</span> N==<span class="hljs-number">0</span>;&#125;<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">size</span>()</span> &#123;<span class="hljs-keyword">return</span> N;&#125;<br></code></pre></td></tr></table></figure><h3 id="2-上浮和下沉操作"><a href="#2-上浮和下沉操作" class="headerlink" title="2. 上浮和下沉操作"></a>2. 上浮和下沉操作</h3><p>在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swim</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">1</span> &amp;&amp; heap[k/<span class="hljs-number">2</span>]&lt;heap[k])<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(k/<span class="hljs-number">2</span>, k);<br>        k = k/<span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似地，当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，<br>应当与两个子节点中最大那个节点进行交换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">2</span> * k &lt;= N)<br>    &#123;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * k;<br>        <span class="hljs-keyword">if</span> (j &lt; N &amp;&amp; heap[j]&lt;heap[j+<span class="hljs-number">1</span>])  <span class="hljs-comment">//如果节点k有两个子节点，选出最大子节点</span><br>            j++;<br>        <span class="hljs-keyword">if</span> (heap[k]&gt;heap[j])    <span class="hljs-comment">//如果最大子节点不大于节点k，下沉完成</span><br>            beak;<br>        <span class="hljs-built_in">swap</span>(k, j); <span class="hljs-comment">//如果最大子节点大于节点k，交换最大子节点和节点k，继续下沉</span><br>        k = j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-插入元素"><a href="#3-插入元素" class="headerlink" title="3. 插入元素"></a>3. 插入元素</h3><p>将新元素放到数组末尾，然后上浮到合适位置</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    heap[++N] = v;<br>    <span class="hljs-built_in">swim</span>(N);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-删除堆顶元素"><a href="#4-删除堆顶元素" class="headerlink" title="4. 删除堆顶元素"></a>4. 删除堆顶元素</h3><p>从数组顶端删除最大元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> delMax<br>&#123;<br>    <span class="hljs-type">int</span> max = heap[<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">swap</span>(<span class="hljs-number">1</span>, N--);<br>    heap[N+<span class="hljs-number">1</span>] = null;<br>    <span class="hljs-built_in">sink</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、堆排序"><a href="#二、堆排序" class="headerlink" title="二、堆排序"></a>二、堆排序</h2><p>给定一个数组，将其使用堆排序进行排序。需要先使用sink函数将这个数组构造成最大堆，接下来每次讲堆顶的最大元素取下来与数组的最后一个元素交换，这时候最大堆的结构已经被破坏，将数组元素个数减一并且对新的堆顶元素调用sink函数使数组恢复最大堆，重复执行这个过程，直到所有元素都已排序。</p><h3 id="1-构建堆"><a href="#1-构建堆" class="headerlink" title="1. 构建堆"></a>1. 构建堆</h3><p>无序数组建立堆最直接的方法就是从左到右遍历数组进行上浮操作。</p><p>一个更高效的方法是从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为<br>根节点的堆有序。叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要便利一半的元素即可。</p><h3 id="2-交换堆顶元素与最后一个元素"><a href="#2-交换堆顶元素与最后一个元素" class="headerlink" title="2. 交换堆顶元素与最后一个元素"></a>2. 交换堆顶元素与最后一个元素</h3><p>交换之后需要进行下沉操作维持堆的有序状态</p><h3 id="3-完整代码"><a href="#3-完整代码" class="headerlink" title="3. 完整代码"></a>3. 完整代码</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> size = num.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = size/<span class="hljs-number">2</span>; k &gt;= <span class="hljs-number">1</span>; k--)<br>        <span class="hljs-built_in">sink</span>(nums, k, N);<br>    <span class="hljs-keyword">while</span> (N &gt; <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(nums, <span class="hljs-number">1</span>, N--);<br>        <span class="hljs-built_in">sink</span>(nums, <span class="hljs-number">1</span>, N);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sink</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">2</span> * k &lt;= N)<br>    &#123;<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * k;<br>        <span class="hljs-keyword">if</span> (j &lt; N &amp;&amp; heap[j]&lt;heap[j+<span class="hljs-number">1</span>])<br>            j++;<br>        <span class="hljs-keyword">if</span> (heap[k]&gt;heap[j])<br>            beak;<br>        <span class="hljs-built_in">swap</span>(k, j);<br>        k = j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、性能分析"><a href="#三、性能分析" class="headerlink" title="三、性能分析"></a>三、性能分析</h2><p>堆高度为logN，因此在堆中插入元素和删除最大元素的复杂度都为logN</p><p>堆排序：要对N个节点进行下沉操作，所以时间复杂度为NlogN</p><p>堆排序为原地排序，不需要额外空间</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>比较排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>选择排序</title>
    <link href="/2022/03/03/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/03/03/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、简单选择排序"><a href="#一、简单选择排序" class="headerlink" title="一、简单选择排序"></a>一、简单选择排序</h2><p>选择排序每次遍历数组时，从数组中未排序部分中选择出最大（最小）元素，并将该元素与未排序部分的最后一个（第一个）元素交换，最后得到有序数组</p><figure class="highlight arduino"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> min_i = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        min_i = i;<br>        <span class="hljs-comment">//选出最小值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; size; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[min_i])<br>                min_i = j;<br>        &#125;<br>        <span class="hljs-comment">//将未排序部分的第一个元素与最小元素交换</span><br>        <span class="hljs-built_in">swap</span>(nums, i, min_i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div align="center"><img src="selection_sort.gif"></img></div><h2 id="二、优化"><a href="#二、优化" class="headerlink" title="二、优化"></a>二、优化</h2><h3 id="1-一次遍历，双向选择"><a href="#1-一次遍历，双向选择" class="headerlink" title="1. 一次遍历，双向选择"></a>1. 一次遍历，双向选择</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//二元选择排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">select_sort</span><span class="hljs-params">( vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> mini; <br>    <span class="hljs-type">int</span> maxi;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size/<span class="hljs-number">2</span>; i++ )<br>    &#123;<br>        mini = i;<br>        maxi = i;<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j &lt; size-i; j++ )<br>        &#123;<br>            <span class="hljs-keyword">if</span> ( nums[j] &lt; nums[mini] )<br>                mini = j;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( nums[j] &gt; nums[maxi] )<br>                maxi = j;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ( mini != i )<br>            <span class="hljs-built_in">swap</span>( nums[i], nums[mini] );<br>        <span class="hljs-keyword">if</span> ( maxi != i &amp;&amp; maxi != j )<br>            <span class="hljs-built_in">swap</span>( nums[j<span class="hljs-number">-1</span>], nums[maxi] );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三、性能分析"><a href="#三、性能分析" class="headerlink" title="三、性能分析"></a>三、性能分析</h2><ul><li>时间复杂度：O(N<sup>2</sup>)</li><li>空间复杂度：O(1)</li><li>稳定性：不稳定</li><li>排序方式：原地排序</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>比较排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插入排序</title>
    <link href="/2022/03/03/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/03/03/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="一、简单插入排序"><a href="#一、简单插入排序" class="headerlink" title="一、简单插入排序"></a>一、简单插入排序</h2><p>插入排序将数组分为排序区和乱序区，排序过程中每次从乱序区中选择一个元素放入排序区，直到乱序区没有元素</p><figure class="highlight arduino"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertion</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; size; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt; <span class="hljs-number">0</span> &amp;&amp; （nums[j] &lt; nums[j<span class="hljs-number">-1</span>]）; j--)<br>        &#123;<br>            <span class="hljs-built_in">swap</span>(nums, j, j - <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、优化"><a href="#二、优化" class="headerlink" title="二、优化"></a>二、优化</h2><h3 id="1-融合二分查找"><a href="#1-融合二分查找" class="headerlink" title="1. 融合二分查找"></a>1. 融合二分查找</h3><p>使用二分查找快速查找新元素在排序区的位置</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//哨兵和二分查找相结合的插入排序</span><br>void insert<span class="hljs-constructor">_sort( <span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span> )</span><br>&#123;<br>    <span class="hljs-built_in">int</span> target;<br>    <span class="hljs-built_in">int</span> k;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; size; ++i )<br>    &#123;<br>        target = nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>        <span class="hljs-comment">//找到target应该插入的位置</span><br>        k = bin<span class="hljs-constructor">_search( <span class="hljs-params">nums</span>, 0, <span class="hljs-params">i</span>, <span class="hljs-params">target</span> )</span>;<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-built_in">int</span> j = i-<span class="hljs-number">1</span>; j &gt;= k; --j )<br>        &#123;<br>            nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>+<span class="hljs-number">1</span>]</span> = nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>        &#125;<br>        nums<span class="hljs-literal">[<span class="hljs-identifier">k</span>]</span> = target;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-加入哨兵位"><a href="#2-加入哨兵位" class="headerlink" title="2. 加入哨兵位"></a>2. 加入哨兵位</h3><p>在将新元素插入排序区使用哨兵位避免频繁交换元素的开销</p><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stan"><span class="hljs-comment">//带哨兵的插入排序</span><br><span class="hljs-type">void</span> insert_sort( <span class="hljs-type">vector</span>&lt;<span class="hljs-type">int</span>&gt;&amp; nums )<br>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">size</span> = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> sentry;<br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">size</span>; ++i )<br>    &#123;<br>        sentry = nums[i];<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> j = i-<span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j-- )<br>        &#123;<br>            <span class="hljs-keyword">if</span> ( sentry &lt; <span class="hljs-type">array</span>[j] )<br>                nums[j+<span class="hljs-number">1</span>] = nums[j];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> ( j+<span class="hljs-number">1</span> != i )<br>            nums[j+<span class="hljs-number">1</span>] = sentry;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div align="center"><img src="insert_sort3.gif"></img></div><h2 id="三、性能分析"><a href="#三、性能分析" class="headerlink" title="三、性能分析"></a>三、性能分析</h2><ul><li>时间复杂度：O(N<sup>2</sup>)</li><li>空间复杂度：O(1)</li><li>排序方式：原地</li><li>稳定性：稳定</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>比较排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冒泡排序</title>
    <link href="/2022/03/03/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/03/03/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>冒泡排序是最基本的排序方式，是在每次遍历时，通过交换相邻元素将未排序元素中最大元素（最小元素）沉下去（浮上来）的过程。</p><h2 id="一、经典的冒泡排序："><a href="#一、经典的冒泡排序：" class="headerlink" title="一、经典的冒泡排序："></a>一、经典的冒泡排序：</h2><figure class="highlight arduino"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">//外层循环：每次循环排序好一个元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; size - i; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[j - <span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(nums, j, j - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div align="center"><img src="bubble_sort.gif"/></div><h2 id="二、优化"><a href="#二、优化" class="headerlink" title="二、优化"></a>二、优化</h2><h3 id="1-阻止数组排好序之后无意义的循环"><a href="#1-阻止数组排好序之后无意义的循环" class="headerlink" title="1. 阻止数组排好序之后无意义的循环"></a>1. 阻止数组排好序之后无意义的循环</h3><p>上面经典冒泡排序法在数组的数据已经排好的情况下，仍会继续进行下一轮循环遍历，进行无意义的循环，通过增加标记位来处理这种情况</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">bool</span> has_sorted = <span class="hljs-literal">false</span>;    <span class="hljs-comment">//记录nums是否已经是排序数组的标记</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size - <span class="hljs-number">1</span> &amp;&amp; !has_sorted; i++)<br>    &#123;<br>        has_sorted = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; size - i; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] &lt; nums[j - <span class="hljs-number">1</span>])<br>            &#123;<br>                has_sorted = <span class="hljs-literal">false</span>;<br>                <span class="hljs-built_in">swap</span>(nums, j, j - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-优化内层循环"><a href="#2-优化内层循环" class="headerlink" title="2. 优化内层循环"></a>2. 优化内层循环</h3><p>每次记住每趟第一次交换的位置和最后一次交换的位置，第一次交换位置之前的元素都已经排好序了，同理，最后一次交换的位置之后的元素都已经排好序了</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">( vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> last_swap_end = size - <span class="hljs-number">1</span>, last_swap_start = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> q = size <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> p = last_swap_start;<br>    <span class="hljs-type">int</span> first_flag = <span class="hljs-number">1</span>;     <span class="hljs-comment">//记录是否为第一次交换</span><br>    <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size<span class="hljs-number">-1</span>; i++ )<br>    &#123;<br>        <span class="hljs-keyword">for</span> ( <span class="hljs-type">int</span> j = p; j &lt; q; j++ )<br>        &#123;<br>            <span class="hljs-keyword">if</span> ( nums[j] &gt; nums[j+<span class="hljs-number">1</span>] )<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(nums[j], nums[j+<span class="hljs-number">1</span>]);<br>                last_swap_end = j;<br>                <span class="hljs-keyword">if</span> ( first_flag )<br>                &#123;<br>                    last_swap_start = j == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : j <span class="hljs-number">-1</span>;<br>                    first_flag = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        q = last_swap_end;<br>        first_flag = <span class="hljs-number">1</span>;<br>        p = last_swap_start;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-双向冒泡排序法（鸡尾酒排序法）"><a href="#3-双向冒泡排序法（鸡尾酒排序法）" class="headerlink" title="3. 双向冒泡排序法（鸡尾酒排序法）"></a>3. 双向冒泡排序法（鸡尾酒排序法）</h3><p>鸡尾酒排序是冒泡排序的一种改进和变型 ，又称“双向冒泡排序”，鸡尾酒排序是从低到高然后从高到低来回排序（选出最大和最小项），比冒泡排序的效率稍微好一点，原因是冒泡排序只从一个方向进行比对(由低到高)，每次循环只移动一个项目</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 鸡尾酒排序(C++)</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CockTailSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;vi)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> isSorted=<span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//双向同时进行</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vi.<span class="hljs-built_in">size</span>()/<span class="hljs-number">2</span> &amp;&amp; !isSorted; i++)<br>    &#123;<br>        isSorted = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//升序排列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i;j &lt; vi.<span class="hljs-built_in">size</span>()-i<span class="hljs-number">-1</span>; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(vi[j] &gt; vi[j+<span class="hljs-number">1</span>])<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(vi[j], vi[j + <span class="hljs-number">1</span>]);<br>                isSorted = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//降序排列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = vi.<span class="hljs-built_in">size</span>()-i<span class="hljs-number">-1</span>; j&gt;i; j--)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(vi[j] &lt; vi[j<span class="hljs-number">-1</span>])<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(vi[j], vi[j - <span class="hljs-number">1</span>]);<br>                isSorted = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div align="center"><img src="double_bubble.gif"/></div><h2 id="三、性能分析"><a href="#三、性能分析" class="headerlink" title="三、性能分析"></a>三、性能分析</h2><ul><li>平均时间复杂度：O(N<sup>2</sup>)</li><li>最坏时间复杂度：O(N<sup>2</sup>)，出现在当前数组被逆序排序</li><li>最好时间复杂度：O(N)，出现在优化1的版本中，输入的数组已经被排好序时</li><li>稳定性：稳定，相等元素在排序前后保持相对位置不变</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>比较排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2022/03/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/03/03/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>最好情况：每次正好将数组分半，O(NlogN)</p><p>最坏情况：输入的输入已经排好序，O(N^2)</p><p>为了防止出现最坏情况，需要在进行快速排序前随机打乱数组以避免数组已经排好序</p><h2 id="一、经典快速排序"><a href="#一、经典快速排序" class="headerlink" title="一、经典快速排序"></a>一、经典快速排序</h2><h3 id="1-主要过程"><a href="#1-主要过程" class="headerlink" title="1. 主要过程"></a>1. 主要过程</h3>  <figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">void quick<span class="hljs-constructor">_sort_core(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">h</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (h &lt;= l)<br>        return;<br>    <span class="hljs-built_in">int</span> m = partition(nums, l, h);<br>    quick<span class="hljs-constructor">_sort_core(<span class="hljs-params">nums</span>, <span class="hljs-params">l</span>, <span class="hljs-params">m</span> - 1)</span>;<br>    quick<span class="hljs-constructor">_sort_core(<span class="hljs-params">nums</span>, <span class="hljs-params">m</span> + 1, <span class="hljs-params">h</span>)</span>;<br>&#125;<br>void quick<span class="hljs-constructor">_sort(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>)</span><br>&#123;<br>    quick<span class="hljs-constructor">_sort_core(<span class="hljs-params">nums</span>, 0, <span class="hljs-params">nums</span>.<span class="hljs-params">size</span>()</span> - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-partition函数"><a href="#2-partition函数" class="headerlink" title="2. partition函数"></a>2. partition函数</h3>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> h)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = l, j = h + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> v = nums[l];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (nums[++i] &lt; v &amp;&amp; i != h);<br>        <span class="hljs-keyword">while</span> (v &lt; nums[--j] &amp;&amp; j != l);<br>        <span class="hljs-keyword">if</span> (i &gt;= j)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-built_in">swap</span>(nums, i, j);<br>    &#125;<br>    <span class="hljs-built_in">swap</span>(nums, l, j);<br>    <span class="hljs-keyword">return</span> j;<br>&#125;<br></code></pre></td></tr></table></figure><p>  partition函数的另一种写法，参考<a href="https://github.com/haigangx/leetcode/blob/master/algorithms/215_kth_largest_element_in_an_array.md">Leetcode</a></p><div align="center"><img src="quick_sort.gif" /></div><h2 id="二、改进"><a href="#二、改进" class="headerlink" title="二、改进"></a>二、改进</h2><h3 id="1-随机快排"><a href="#1-随机快排" class="headerlink" title="1.随机快排"></a>1.随机快排</h3><div align="center"><img src="random_quick_sort.gif" /></div><h3 id="2-切换到插入排序"><a href="#2-切换到插入排序" class="headerlink" title="2. 切换到插入排序"></a>2. 切换到插入排序</h3><p>因为快速排序在小数组中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序</p><h3 id="3-三数取中"><a href="#3-三数取中" class="headerlink" title="3. 三数取中"></a>3. 三数取中</h3><p>三取样切分跟随机快排一样，也是从寻找最优的切分点这个方向上来优化快排。</p><p>三取样切分即是使用数组中的小部分元素的中位数来切分数组，这样做的切分更好，但是会带来计算中位数的负担，人们发现将取样大小设为3并用大小居中的元素切分效果最好。</p><h3 id="4-三向切分"><a href="#4-三向切分" class="headerlink" title="4. 三向切分"></a>4. 三向切分</h3><p>熵最优的排序（三向切分）主要是为了处理数组中有大量重复元素的情况，如果数组中有大量重复的元素，如果不考虑对重复元素做特殊处理，就会少了一个优化的好机会，比如，一个元素全部重复的数组就不需要在进行排序了。</p><p>一个简单的想法就是将数组的元素分成三部分，大于哨兵的，小于哨兵的和等于哨兵的。这个问题有一个解法，就是<strong>Dijkstra解法</strong>，<a href="https://leetcode-cn.com/problems/sort-colors/">荷兰国旗问题</a>可以通过此法解决，三向切分快速排序对于只有若干不同主键的随机数组可以在线性时间内完成排序</p><blockquote><p><strong>Dijkstra解法</strong>的主要思路是：从左到右遍历数组一次，维护一个指针lt，使得data[lo…lt-1]的所有元素都小于哨兵，一个指针gt，使得data[gt+1…hi]之间的元素都大于哨兵，维护一个指针i，使得data[lt…i-1]之间的元素都等于哨兵，data[i…gt]之间的元素还未处理。</p></blockquote><p>具体的处理过程如下，一开始i等于lo，哨兵值等于v：</p><ul><li>如果data[i]小于v，则交换data[i]和data[lt]，lt++, i++;</li><li>如果data[i]大于v，则交换data[i]和data[gt]，gt–;</li><li>如果data[i]等于v，i++;</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void three<span class="hljs-constructor">_way_quick_sort(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">h</span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (h &lt;= l)<br>        return;<br>    <span class="hljs-built_in">int</span> lt = l, i = l + <span class="hljs-number">1</span>, gt = h;<br>    <span class="hljs-built_in">int</span> v = nums<span class="hljs-literal">[<span class="hljs-identifier">l</span>]</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; gt)<br>    &#123;<br>        <span class="hljs-built_in">int</span> cmp = nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> - v;<br>        <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)<br>            swap(nums, lt++, i++);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>)<br>            swap(nums, i, gt--);<br>        <span class="hljs-keyword">else</span><br>            i++;<br>    &#125;<br>    three<span class="hljs-constructor">_way_quick_sort(<span class="hljs-params">nums</span>, <span class="hljs-params">l</span>, <span class="hljs-params">lt</span>-1)</span>;<br>    three<span class="hljs-constructor">_way_quick_sort(<span class="hljs-params">nums</span>, <span class="hljs-params">gt</span>+1, <span class="hljs-params">h</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-基于切分的快速选择算法"><a href="#5-基于切分的快速选择算法" class="headerlink" title="5. 基于切分的快速选择算法"></a>5. 基于切分的快速选择算法</h3><p>快速排序的partition方法，会返回一个整数j使得a[l..j-1]小于等于a[j],且a[j+1..h]大于等于a[j]，此时a[j]就是数组的第j大元素</p><p>可以利用这个特性找出数组的第k个元素</p><p>该算法是线性级别的，假设每次能将数组二分，那么比较的总次数为(N+N&#x2F;2+N&#x2F;4+…)，直到找到第k个元素，这个和显然小于2N</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectK</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, h = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span> (h &gt; l)<br>    &#123;<br>        <span class="hljs-type">int</span> j = <span class="hljs-built_in">partition</span>(nums, l, h);<br>        <span class="hljs-keyword">if</span> (j == k)<br>            <span class="hljs-keyword">return</span> nums[k];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j &gt; k)<br>            h = j - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            l = j + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums[k];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
      <category>算法</category>
      
      <category>排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>比较排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
